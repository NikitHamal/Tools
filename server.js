// YouTube transcription server using only free methods
const express = require('express');
const cors = require('cors');
const axios = require('axios');
const { parseString } = require('xml2js');
const fs = require('fs');
const path = require('path');
const youtubeDownloader = require('ytdl-core');
const natural = require('natural');
const tokenizer = new natural.WordTokenizer();

const app = express();
const PORT = process.env.PORT || 5000;

app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Custom transcript cache to avoid repeated processing
const transcriptCache = new Map();

// Function to extract transcript URL from YouTube page
async function getTranscriptUrl(videoId) {
  try {
    // Fetch the video page
    const response = await axios.get(`https://www.youtube.com/watch?v=${videoId}`);
    
    // Extract the caption tracks information
    const pageContent = response.data;
    const captionTracksMatch = pageContent.match(/"captionTracks":\[(.*?)\]/);
    
    if (!captionTracksMatch || captionTracksMatch.length < 2) {
      throw new Error('No caption tracks found');
    }
    
    const captionTracks = JSON.parse(`{"captionTracks":[${captionTracksMatch[1]}]}`);
    
    // First try to find manual captions (more accurate)
    let englishTrack = captionTracks.captionTracks.find(track => 
      (track.languageCode === 'en' || track.name.simpleText === 'English') && 
      track.kind !== 'asr' // 'asr' indicates auto-generated
    );
    
    // If no manual captions, fall back to auto-generated
    if (!englishTrack) {
      englishTrack = captionTracks.captionTracks.find(track => 
        track.languageCode === 'en' || track.name.simpleText === 'English'
      );
    }
    
    // If no English, just take first available
    if (!englishTrack) {
      englishTrack = captionTracks.captionTracks[0];
    }
    
    if (!englishTrack || !englishTrack.baseUrl) {
      throw new Error('No suitable caption track found');
    }
    
    return {
      url: englishTrack.baseUrl,
      isAutoGenerated: englishTrack.kind === 'asr',
      language: englishTrack.languageCode || 'unknown'
    };
  } catch (error) {
    console.error('Error extracting transcript URL:', error);
    throw error;
  }
}

// Function to fetch and parse transcript from YouTube captions
async function fetchTranscript(transcriptUrl) {
  try {
    const response = await axios.get(transcriptUrl);
    const xmlData = response.data;
    
    // Parse XML to JSON
    let transcript = [];
    parseString(xmlData, (err, result) => {
      if (err) throw err;
      
      if (result && result.transcript && result.transcript.text) {
        transcript = result.transcript.text.map(item => ({
          text: item._, 
          start: parseFloat(item.$.start),
          duration: parseFloat(item.$.dur)
        }));
      }
    });
    
    return transcript;
  } catch (error) {
    console.error('Error fetching transcript:', error);
    throw error;
  }
}

// Alternative method: Get transcript from 3rd party free API (as fallback)
async function fetchTranscriptFromFreeAPI(videoId) {
  try {
    // Try to use a free third-party API
    const response = await axios.get(`https://youtubetranscript.com/?server_vid=${videoId}`);
    
    if (response.data && response.data.length > 0) {
      // Transform the data to match our format
      return response.data.map(item => ({
        text: item.text,
        start: parseFloat(item.start),
        duration: parseFloat(item.duration)
      }));
    }
    
    throw new Error('No transcript data from free API');
  } catch (error) {
    console.error('Error fetching from free API:', error);
    throw error;
  }
}

// Fetch transcript from YouTube Data API v3 (if user adds their own API key)
async function fetchTranscriptFromYoutubeAPI(videoId, apiKey) {
  try {
    if (!apiKey) {
      throw new Error('YouTube API key not provided');
    }
    
    // First get the caption track ID
    const videoResponse = await axios.get(
      `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${apiKey}`
    );
    
    if (!videoResponse.data.items || videoResponse.data.items.length === 0) {
      throw new Error('Video not found');
    }
    
    // Then get the captions
    const captionsResponse = await axios.get(
      `https://www.googleapis.com/youtube/v3/captions?part=snippet&videoId=${videoId}&key=${apiKey}`
    );
    
    if (!captionsResponse.data.items || captionsResponse.data.items.length === 0) {
      throw new Error('No captions found');
    }
    
    // Get the English caption track ID
    const captionId = captionsResponse.data.items.find(
      item => item.snippet.language === 'en'
    )?.id;
    
    if (!captionId) {
      throw new Error('No English captions found');
    }
    
    // Get the caption content
    const captionResponse = await axios.get(
      `https://www.googleapis.com/youtube/v3/captions/${captionId}?key=${apiKey}`
    );
    
    // Transform to our format
    return captionResponse.data.map(item => ({
      text: item.text,
      start: item.start,
      duration: item.duration
    }));
  } catch (error) {
    console.error('Error fetching from YouTube API:', error);
    throw error;
  }
}

// Post-process transcript to improve readability and accuracy
function postProcessTranscript(transcript, quality = 'standard') {
  // Apply different levels of post-processing based on quality parameter
  return transcript.map(item => {
    // Clean up common transcription errors
    let text = item.text
      .replace(/(\w)\.(\w)/g, "$1. $2") // Fix missing spaces after periods
      .replace(/(\w),(\w)/g, "$1, $2") // Fix missing spaces after commas
      .replace(/\s+/g, " ") // Normalize spaces
      .trim();
    
    // Basic processing for all quality levels
    if (text.length > 0) {
      text = text.charAt(0).toUpperCase() + text.slice(1);
    }
    
    // More advanced processing for high quality
    if (quality === 'high') {
      text = text
        .replace(/(\b)i(\b)/g, "$1I$2") // Fix standalone lowercase i
        .replace(/(\b)im(\b)/g, "$1I'm$2") // Fix im → I'm
        .replace(/(\b)dont(\b)/g, "$1don't$2") // Fix dont → don't
        .replace(/(\b)cant(\b)/g, "$1can't$2") // Fix cant → can't
        .replace(/(\b)wont(\b)/g, "$1won't$2"); // Fix wont → won't
    }
    
    return {
      ...item,
      text
    };
  });
}

// Merge captions from multiple sources
function mergeTranscripts(transcripts) {
  // If we only have one transcript source, just return it
  if (transcripts.length === 1) {
    return transcripts[0];
  }
  
  // Start with the transcript that has the most entries as primary
  const primary = transcripts.reduce((max, current) => 
    current.length > max.length ? current : max, transcripts[0]);
  
  // Align and merge with other transcripts based on time
  transcripts.forEach(transcript => {
    if (transcript === primary) return;
    
    transcript.forEach(item => {
      // Find matching segment in primary transcript based on timing
      const matchingSegment = primary.find(segment => 
        Math.abs(segment.start - item.start) < 1.0); // 1 second tolerance
      
      if (matchingSegment) {
        // If the alternative text is significantly different, keep both versions
        if (!areSimilarTexts(matchingSegment.text, item.text)) {
          matchingSegment.alternativeText = item.text;
        }
      } else {
        // Add new segments that weren't in the primary transcript
        primary.push(item);
      }
    });
  });
  
  // Sort by start time
  primary.sort((a, b) => a.start - b.start);
  
  return primary;
}

// Compare two text segments for similarity
function areSimilarTexts(text1, text2) {
  if (!text1 || !text2) return false;
  
  const tokens1 = tokenizer.tokenize(text1.toLowerCase());
  const tokens2 = tokenizer.tokenize(text2.toLowerCase());
  
  if (!tokens1 || !tokens2 || tokens1.length === 0 || tokens2.length === 0) {
    return false;
  }
  
  // Calculate Jaccard similarity
  const set1 = new Set(tokens1);
  const set2 = new Set(tokens2);
  
  const intersection = new Set([...set1].filter(x => set2.has(x)));
  const union = new Set([...set1, ...set2]);
  
  return intersection.size / union.size > 0.7; // 70% similarity threshold
}

// Use OCR to extract hardcoded subtitles (for videos with burned-in captions)
async function extractHardcodedSubtitles(videoId) {
  // This is a placeholder for a real implementation
  // We'd need to:
  // 1. Download video frames at regular intervals
  // 2. Use Tesseract.js or similar free OCR library to extract text
  // 3. Format the results as transcript data
  
  console.log('OCR subtitle extraction not implemented yet');
  return [];
}

// Generate cache key that includes quality
function getCacheKey(videoId, quality, method) {
  return `${videoId}-${quality}-${method}`;
}

// Main API endpoint for transcript retrieval
app.get('/api/transcript', async (req, res) => {
  try {
    const { videoId, quality = 'standard', method = 'auto', youtubeApiKey = '' } = req.query;
    
    if (!videoId) {
      return res.status(400).json({ error: 'Video ID is required' });
    }
    
    // Check cache first 
    const cacheKey = getCacheKey(videoId, quality, method);
    if (transcriptCache.has(cacheKey)) {
      console.log('Serving transcript from cache');
      return res.json({ transcript: transcriptCache.get(cacheKey) });
    }
    
    // Try to use multiple transcription methods for better accuracy
    const transcriptSources = [];
    let transcriptData;
    let transcriptMethod = 'YouTube captions';
    
    // Method 1: Use YouTube's built-in captions
    try {
      transcriptData = await getTranscriptUrl(videoId);
      const youtubeTranscript = await fetchTranscript(transcriptData.url);
      
      if (youtubeTranscript && youtubeTranscript.length > 0) {
        transcriptSources.push(youtubeTranscript);
      }
    } catch (error) {
      console.log('YouTube caption fetch failed, trying alternative methods');
    }
    
    // Method 2: Try the YouTube Data API if user provided an API key
    if (youtubeApiKey && transcriptSources.length === 0) {
      try {
        const apiTranscript = await fetchTranscriptFromYoutubeAPI(videoId, youtubeApiKey);
        if (apiTranscript && apiTranscript.length > 0) {
          transcriptSources.push(apiTranscript);
          transcriptMethod = 'YouTube API';
        }
      } catch (error) {
        console.log('YouTube API fetch failed');
      }
    }
    
    // Method 3: Try a free 3rd party API as fallback
    if (transcriptSources.length === 0) {
      try {
        const freeApiTranscript = await fetchTranscriptFromFreeAPI(videoId);
        if (freeApiTranscript && freeApiTranscript.length > 0) {
          transcriptSources.push(freeApiTranscript);
          transcriptMethod = 'Free API';
        }
      } catch (error) {
        console.log('Free API fetch failed');
      }
    }
    
    // Method 4: For videos with hardcoded subtitles, try OCR (if implemented)
    if (method === 'ocr' || (method === 'auto' && transcriptSources.length === 0)) {
      try {
        const ocrTranscript = await extractHardcodedSubtitles(videoId);
        if (ocrTranscript && ocrTranscript.length > 0) {
          transcriptSources.push(ocrTranscript);
          transcriptMethod = 'OCR';
        }
      } catch (error) {
        console.log('OCR extraction failed');
      }
    }
    
    if (transcriptSources.length === 0) {
      throw new Error('Could not generate transcript from any source. This video may not have captions available.');
    }
    
    // Merge transcripts from different sources if we have multiple
    let finalTranscript = mergeTranscripts(transcriptSources);
    
    // Post-process to improve quality
    finalTranscript = postProcessTranscript(finalTranscript, quality);
    
    // Cache the result
    transcriptCache.set(cacheKey, finalTranscript);
    
    return res.json({ 
      transcript: finalTranscript,
      meta: {
        sources: transcriptSources.length,
        method: transcriptMethod,
        quality: quality,
        language: transcriptData?.language || 'en'
      }
    });
  } catch (error) {
    console.error('Error processing transcript request:', error);
    return res.status(500).json({ 
      error: 'Failed to fetch transcript', 
      details: error.message,
      userMessage: 'Could not obtain captions for this video. It may not have captions available, or they may be disabled by the video owner.'
    });
  }
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
}); 